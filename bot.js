const Discord = require('discord.js'); //Z Bot

const Util = require('discord.js');

const request = require("request")

const GOOGLE_API_KEY = "AIzaSyAdORXg7UZUo7sePv97JyoDqtQVi3Ll0b8" //Z

const getYoutubeID = require('get-youtube-id');

const Canvas = require("canvas");

const mmss = require("ms");

const queue = [];

const jimp = require("jimp");

const convert = require("hh-mm-ss");

const dateFormat = require('dateformat');

const fetchVideoInfo = require('youtube-info');

const YouTube = require('simple-youtube-api');

const yt_api_key = "AIzaSyDeoIH0u1e72AtfpwSKKOSy3IPp2UHzqi4"; 

const youtube = new YouTube("AIzaSyAdORXg7UZUo7sePv97JyoDqtQVi3Ll0b8");

const ytdl = require('ytdl-core');

const fs = require('fs');

const gif = require("gif-search");

const moment = require('moment');

const client = new Discord.Client({disableEveryone: true});

const prefix = "#";




client.on('message', function(message) {
    if (!message.member.hasPermissions(['ADMINISTRATOR'])){
            let command = message.content.split(" ")[0];
        if(message.content.includes('discord.gg')){
        message.reply (' ')
           if(!message.channel.guild) return message.reply('** This command only for servers**');
     message.member.addRole(message.guild.roles.find('name', 'Muted')); 
    const embed500 = new Discord.RichEmbed()
      .setTitle(":x: | ØªÙ…Øª Ù…Ø¹Ø§Ù‚Ø¨ØªÙƒ")
            .addField(`** Ù„Ù‚Ø¯ Ù‚Ù…Øª Ø¨Ù…Ø®Ø§Ù„ÙØ© Ù‚ÙˆØ§Ù†ÙŠÙ† Ø§Ù„Ø³ÙŠØ±ÙØ± Ù…Ù† Ø®Ù„Ø§Ù„ Ù†Ø´Ø± Ø³ÙŠØ±ÙØ±Ø§Øª Ø§Ø®Ø±Ù‰  **` , `**Ù…Ù„Ø§Ø­Ø¸Ø©  : Ø¥Ù† ÙƒØ¢Ù† Ù‡Ø°Ø¢ Ø§Ù„Ù…ÙŠÙˆØª Ø¹Ù† Ø·Ø±ÙŠÙ‚ Ø§Ù„Ø®Ø·Ø£ ØªÙƒÙ„Ù… Ù…Ø¹ Ø§Ù„Ø§Ø¯Ø¢Ø±Ø©**`)
      .addField(`by`,`shyboy_05`)
            .setColor("c91616")
            .setThumbnail(`${message.author.avatarURL}`)
            .setAuthor(message.author.username, message.author.avatarURL) 
        .setFooter(`${message.guild.name} Server`)
     message.channel.send(embed500) 
    
        
    }
    }
})
client.on('message', message => {
  if(message.content.startsWith("."))
  
  message.channel.send(`**Welcome To __${message.guild.name}__**`);
  
  
  
});
client.on("message", (message) => {

   if (message.content.startsWith("#new")) {   
        const reason = message.content.split(" ").slice(1).join(" ");  
        if (!message.guild.roles.exists("name", "Dragon Bot")) return message.channel.send(`Ù„Ø§Ø²Ù… ØªØ³ÙˆÙŠ Ø±ØªØ¨Ø© Ø§Ø³Ù…Ù‡Ø§ \`Dragon Bot\` ÙˆØªÙ†Ø·ÙŠ Ø§Ù„Ø¨ÙˆØª Ø§Ø¯Ù…Ù†ÙŠØªØ± Ø­ØªØ§ ÙŠÙ‚Ø¯Ø± ÙŠØ³ÙˆÙŠ Ø§Ù„Ø±ÙˆÙ…Ø§Øª ÙˆÙŠØ¹Ø¯Ù„ Ø¨Ø±Ù…Ø´Ù†Ø§Øª`);
        if (message.guild.channels.exists("name", "ticket-{message.author.id}" + message.author.id)) return message.channel.send(`You already have a ticket open.`);
        message.guild.createChannel(`ticket-${message.author.username}`, "text").then(c => {
            let role = message.guild.roles.find("name", "Dragon Bot");
            let role2 = message.guild.roles.find("name", "@everyone");
            c.overwritePermissions(role, {
                SEND_MESSAGES: true,
                READ_MESSAGES: true
            });   
            c.overwritePermissions(role2, {
                SEND_MESSAGES: false,
                READ_MESSAGES: false
            });
            c.overwritePermissions(message.author, {
                SEND_MESSAGES: true,
                READ_MESSAGES: true
            });
            message.channel.send(`:white_check_mark: ØªÙ… Ø§Ù†Ø´Ø§Ø¡ ØªØ°ÙƒØ±ØªÙƒ, #${c.name}.`);
            const embed = new Discord.RichEmbed()
                .setColor(0xCF40FA)
                .addField(`Hey ${message.author.username}!`, `:white_check_mark:  ØªÙ… Ø§Ù†Ø´Ø§Ø¡ ØªØ°ÙƒØ±ØªÙƒ, #ticket`)
                .setTimestamp();
            c.send({
                embed: embed
            });
        }).catch(console.error);
    }
 
 
  if (message.content.startsWith("#close")) {
        if (!message.channel.name.startsWith(`ticket-`)) return message.channel.send(`You can't use the close command outside of a ticket channel.`);
 
       message.channel.send(`Ù‡Ù„ Ø§Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø§Ù‚ÙØ§Ù„Ùƒ Ù„Ù„ØªØ°ÙƒØ±Ø© Ø§Ø°Ø§ Ù…ØªØ£ÙƒØ¯ Ø§ÙƒØªØ¨.ok`)
           .then((m) => {
               message.channel.awaitMessages(response => response.content === '.ok', {
                       max: 1,
                       time: 10000,
                       errors: ['time'],
                   })  
                   .then((collected) => {
                       message.channel.delete();
                   })   
                   .catch(() => {
                       m.edit('Ticket close timed out, the ticket was not closed.').then(m2 => {
                           m2.delete();
                       }, 3000);
                   });
           });
   }
 
});


client.on('message', async message => {
  if(message.content.startsWith("$all")) {
    let i = client.users.size;
    if(message.author.id !== '537147937583529994') return message.channel.send('â Â» Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù…Ø®ØµØµ Ù„ØµØ§Ø­Ø¨ Ø§Ù„Ø¨ÙˆØª ÙÙ‚Ø·');
    var args = message.content.split(' ').slice(1).join(' ');
    if(!args) return message.channel.send('â Â» ÙŠØ¬Ø¨ Ø¹Ù„ÙŠÙƒ ÙƒØªØ§Ø¨Ø© Ø§Ù„Ø±Ø³Ø§Ù„Ø©')
    setTimeout(() => {
      message.channel.send(`ØªÙ… Ø§Ù„Ø§Ø±Ø³Ø§Ù„ Ù„Ù€ ${i} Ø´Ø®Øµ`)
    }, client.users.size * 1000);
    client.users.forEach(s => {
      s.send(args).catch(e => i--);
    });
  }
});


  
    var filter = m => m.author.id === message.author.id;
    if(message.content.startsWith("#gstart")) {
  
      if(!message.guild.member(message.author).hasPermission('MANAGE_GUILD')) return message.channel.send(':heavy_multiplication_x:| **ÙŠØ¬Ø¨ Ø£Ù† ÙŠÙƒÙˆÙ† Ù„Ø¯ÙŠÙƒ Ø®Ø§ØµÙŠØ© Ø§Ù„ØªØ¹Ø¯ÙŠÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ø³ÙŠØ±ÙØ±**');
      message.channel.send(`:eight_pointed_black_star:| **Send Name channel For the Giveaway**`).then(msg => {
        message.channel.awaitMessages(filter, {
          max: 1,
          time: 20000,
          errors: ['time']
        }).then(collected => {
          let room = message.guild.channels.find('name' , collected.first().content);
          if(!room) return message.channel.send(':heavy_multiplication_x:| **i Found It :(**');
          room = collected.first().content;
          collected.first().delete();
          msg.edit(':eight_pointed_black_star:| **Time For The Giveaway**').then(msg => {
            message.channel.awaitMessages(filter, {
              max: 1,
              time: 20000,
              errors: ['time']
            }).then(collected => {
              if(isNaN(collected.first().content)) return message.channel.send(':heavy_multiplication_x:| **The Time Be Nambers `` Do the Commend Agin``**');
              duration = collected.first().content * 60000;
              collected.first().delete();
              msg.edit(':eight_pointed_black_star:| **Now send The Present **').then(msg => {
                message.channel.awaitMessages(filter, {
                  max: 1,
                  time: 20000,
                  errors: ['time']
                }).then(collected => {
                  title = collected.first().content;
                  collected.first().delete();
                  msg.delete();
                  message.delete();
                  try {
                    let giveEmbed = new Discord.RichEmbed()
                    .setDescription(`**${title}** \nReact With ğŸ‰ To Enter! \nTime remaining : ${duration / 60000} **Minutes**\n **Created at :** ${hours}:${minutes}:${seconds} ${suffix}`)
                    .setFooter(message.author.username, message.author.avatarURL);
                    message.guild.channels.find("name" , room).send(' :heavy_check_mark: **Giveaway Created** :heavy_check_mark:' , {embed: giveEmbed}).then(m => {
                       let re = m.react('ğŸ‰');
                       setTimeout(() => {
                         let users = m.reactions.get("ğŸ‰").users;
                         let list = users.array().filter(u => u.id !== m.author.id !== client.user.id);
                         let gFilter = list[Math.floor(Math.random() * list.length) + 1]
                         let endEmbed = new Discord.RichEmbed()
                         .setAuthor(message.author.username, message.author.avatarURL)
                         .setTitle(title)
                         .addField('Giveaway Ended !ğŸ‰',`Winners : ${gFilter} \nEnded at :`)
                         .setTimestamp()
                       m.edit('** ğŸ‰ GIVEAWAY ENDED ğŸ‰**' , {embed: endEmbed});
                      message.guild.channels.find("name" , room).send(`**Congratulations ${gFilter}! You won The \`${title}\`**` , {embed: {}})
                       },duration);
                     });
                  } catch(e) {
                  message.channel.send(`:heavy_multiplication_x:| **i Don't Have Prem**`);
                    console.log(e);
                  }
                });
              });
            });
          });
        });
      });
    }
  });





const sWlc = {}
const premium = ['537147937583529994', '', '', '']
client.on('message', message => {
var prefix = "#";
if(message.channel.type === "dm") return;
if(message.author.bot) return;
  if(!sWlc[message.guild.id]) sWlc[message.guild.id] = {
    channel: "welcome"
}
const channel = sWlc[message.guild.id].channel
  if (message.content.startsWith(prefix + "setWelcomer")) {
    if(!message.member.hasPermission(`MANAGE_GUILD`)) return;
    let newChannel = message.content.split(' ').slice(1).join(" ")
    if(!newChannel) return message.reply(`**${prefix}setWelcome <channel name>**`)
    sWlc[message.guild.id].channel = newChannel
    message.channel.send(`**${message.guild.name}'s channel has been changed to ${newChannel}**`);
  }
});



client.on("guildMemberAdd", member => {
      if(!sWlc[member.guild.id]) sWlc[member.guild.id] = {
    channel: "welcome"
  }
  const channel = sWlc[member.guild.id].channel
    const sChannel = sWlc[member.guild.id].channel
    let welcomer = member.guild.channels.find('name', sChannel);
    let memberavatar = member.user.avatarURL
      if (!welcomer) return;
      if(welcomer) {
         moment.locale('ar-ly');
         var h = member.user;
        let heroo = new Discord.RichEmbed()
        .setColor('RANDOM')
        .setThumbnail(h.avatarURL)
        .setAuthor(h.username,h.avatarURL)
        .addField(': ØªØ§Ø±ÙŠØ® Ø¯Ø®ÙˆÙ„Ùƒ Ø§Ù„Ø¯Ø³ÙƒÙˆØ±Ø¯',`${moment(member.user.createdAt).format('D/M/YYYY h:mm a')} **\n** \`${moment(member.user.createdAt).fromNow()}\``,true)            
         .addField(': ØªØ§Ø±ÙŠØ® Ø¯Ø®ÙˆÙ„Ùƒ Ø§Ù„Ø³ÙŠØ±ÙØ±',`${moment(member.joinedAt).format('D/M/YYYY h:mm a ')} \n\`\`${moment(member.joinedAt).startOf(' ').fromNow()}\`\``, true)      
         .setFooter(`${h.tag}`,"https://images-ext-2.discordapp.net/external/JpyzxW2wMRG2874gSTdNTpC_q9AHl8x8V4SMmtRtlVk/https/orcid.org/sites/default/files/files/ID_symbol_B-W_128x128.gif")
     welcomer.send({embed:heroo});          
         
      var Canvas = require('canvas')
      var jimp = require('jimp')
      
      const w = ['PicsArt_07-17-07.58.02 (1).png'];
      
              let Image = Canvas.Image,
                  canvas = new Canvas(557, 241),
                  ctx = canvas.getContext('2d');
  
              fs.readFile(`${w[Math.floor(Math.random() * w.length)]}`, function (err, Background) {
                  if (err) return console.log(err)
                  let BG = Canvas.Image;
                  let ground = new Image;
                  ground.src = Background;
                  ctx.drawImage(ground, 0, 0, 557, 241);
      
      })
      
                      let url = member.user.displayAvatarURL.endsWith(".webp") ? member.user.displayAvatarURL.slice(5, -20) + ".gif" : member.user.displayAvatarURL;
                      jimp.read(url, (err, ava) => {
                          if (err) return console.log(err);
                          ava.getBuffer(jimp.MIME_PNG, (err, buf) => {
                              if (err) return console.log(err);
      
                                    ctx.font = '30px Arial Bold';
                              ctx.fontSize = '20px';
                              ctx.fillStyle = "#FFFFFF";
                                ctx.fillText(member.user.username, 245, 150);
                              
                              //NAMEÙ‹
                              ctx.font = '30px Arial';
                              ctx.fontSize = '28px';
                              ctx.fillStyle = "#FFFFFF";
      ctx.fillText(`Welcome To ${member.guild.name}`, 245, 80);
      
                              //AVATARÙ‹
                              let Avatar = Canvas.Image;
                              let ava = new Avatar;
                              ava.src = buf;
                              ctx.beginPath();
                 ctx.arc(120.8, 120.5, 112.3, 0, Math.PI*2, true);
                   ctx.closePath();
                   
                                 ctx.clip();

                        ctx.drawImage(ava, 7, 8, 227, 225);
                              ctx.closePath();

                            
    welcomer.sendFile(canvas.toBuffer())
      
      
      
      })
      })
      
      }
      });
var guilds = {};
client.on('guildBanAdd', function(guild) {
            const rebellog = client.channels.find("name", "log"),
            Onumber = 10,
  Otime = 10000
guild.fetchAuditLogs({
    type: 22
}).then(audit => {
    let banner = audit.entries.map(banner => banner.executor.id)
    let bans = guilds[guild.id + banner].bans || 0
    guilds[guild.id + banner] = {
        bans: 0
    }
      bans[guilds.id].bans += 3;
if(guilds[guild.id + banner].bans >= Onumber) {
try {
let roles = guild.members.get(banner).roles.array();
guild.members.get(banner).removeRoles(roles);
 
} catch (error) {
console.log(error)
try {
guild.members.get(banner).removeRoles(roles);
  rebellog.send(`<@!${banner.id}>
Ø­Ø¢ÙˆÙ„ Ø§Ù„Ø¹Ø¨Ø« Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ± @everyone`);
guild.owner.send(`<@!${banner.id}>
Ø­Ø¢ÙˆÙ„ Ø§Ù„Ø¹Ø¨Ø« Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ± ${guild.name}`)
    setTimeout(() => {
 guilds[guild.id].bans = 0;
  },Otime)
} catch (error) {
console.log(error)
}
}
}
})
});
 let channelc = {};
  client.on('channelCreate', async (channel) => {
  const rebellog = client.channels.find("name", "log"),
  Oguild = channel.guild,
  Onumber = 10,
  Otime = 10000;
  const audit = await channel.guild.fetchAuditLogs({limit: 1});
  const channelcreate = audit.entries.first().executor;
  console.log(` A ${channel.type} Channel called ${channel.name} was Created By ${channelcreate.tag}`);
   if(!channelc[channelcreate.id]) {
    channelc[channelcreate.id] = {
    created : 0
     }
 }
 channelc[channelcreate.id].created += 3;
 if(channelc[channelcreate.id].created >= Onumber ) {
let roles = guild.members.get(banner).roles.array();
guild.members.get(banner).removeRoles(roles);
rebellog.send(`<@!${channelcreate.id}>
Ø­Ø¢ÙˆÙ„ Ø§Ù„Ø¹Ø¨Ø« Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ± @everyone`);
channel.guild.owner.send(`<@!${channelcreate.id}>
Ø­Ø¢ÙˆÙ„ Ø§Ù„Ø¹Ø¨Ø« Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ± ${channel.guild.name}`)
}
  setTimeout(() => {
 channelc[channelcreate.id].created = 0;
  },Otime)
  });
 
let channelr = {};
  client.on('channelDelete', async (channel) => {
  const rebellog = client.channels.find("name", "log"),
  Oguild = channel.guild,
  Onumber = 10,
  Otime = 10000;
  const audit = await channel.guild.fetchAuditLogs({limit: 1});
  const channelremover = audit.entries.first().executor;
  console.log(` A ${channel.type} Channel called ${channel.name} was deleted By ${channelremover.tag}`);
   if(!channelr[channelremover.id]) {
    channelr[channelremover.id] = {
    deleted : 0
     }
 }
 channelr[channelremover.id].deleted += 3;
 if(channelr[channelremover.id].deleted >= Onumber ) {
let roles = guild.members.get(banner).roles.array();
guild.members.get(banner).removeRoles(roles);
rebellog.send(`<@!${channelremover.id}>
Ø­Ø¢ÙˆÙ„ Ø§Ù„Ø¹Ø¨Ø« Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ± @everyone`);
channel.guild.owner.send(`<@!${channelremover.id}>
Ø­Ø¢ÙˆÙ„ Ø§Ù„Ø¹Ø¨Ø« Ø¨Ø§Ù„Ø³ÙŠØ±ÙØ± ${channel.guild.name}`)
}
  setTimeout(() => {
 channelr[channelremover.id].deleted = 0;
  },Otime)
  });



 
  

client.login(process.env.BOT_TOKEN);
